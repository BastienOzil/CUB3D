================================================================================
                  EXPLICATION DÃ‰TAILLÃ‰E DU RAY-CASTING
                         Pour le projet CUB3D
================================================================================

TABLE DES MATIÃˆRES
==================
1. Concept global : Comment Ã§a marche ?
2. Fonction principale : raycasting()
3. Fonction init_ray() - Initialiser le rayon
4. Fonction perform_dda() - Trouver le mur
5. Fonction calculate_wall_distance() - Calculer la distance
6. Fonction draw_vertical_line() - Dessiner la colonne
7. RÃ©capitulatif complet
8. Analogie finale


================================================================================
1. CONCEPT GLOBAL : COMMENT Ã‡A MARCHE ?
================================================================================

Imaginez que vous Ãªtes dans un labyrinthe et que vous regardez devant vous.
Le ray-casting simule votre vision en :

1. LanÃ§ant des RAYONS (comme des lasers) depuis votre position
2. Un rayon par COLONNE de l'Ã©cran (si l'Ã©cran fait 1280 pixels de large,
   on lance 1280 rayons)
3. Chaque rayon cherche le MUR LE PLUS PROCHE
4. On dessine une LIGNE VERTICALE proportionnelle Ã  la distance du mur


Vue d'ensemble :
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚           Ã‰CRAN (1280 x 720)            â”‚
                        â”œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¤
                        â”‚ 0 â”‚ 1 â”‚ 2 â”‚ 3 â”‚ 4 â”‚...â”‚...â”‚1277â”‚1278â”‚1279â”‚
                        â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
                          â†“   â†“   â†“   â†“   â†“         â†“   â†“   â†“
                         Un rayon pour chaque colonne de l'Ã©cran


Pourquoi colonne par colonne ?
-------------------------------
Chaque colonne de l'Ã©cran reprÃ©sente un "rayon" de vision :
  â€¢ Colonne 0    = ce qu'on voit tout Ã  GAUCHE
  â€¢ Colonne 640  = ce qu'on voit au CENTRE
  â€¢ Colonne 1279 = ce qu'on voit tout Ã  DROITE


================================================================================
2. FONCTION PRINCIPALE : raycasting()
================================================================================

Pseudo-code simplifiÃ© :
-----------------------

void raycasting(t_game *game)
{
    int x = 0;
    
    // Pour CHAQUE colonne de l'Ã©cran
    while (x < SCREEN_WIDTH)  // 0 Ã  1279
    {
        // 1. PrÃ©parer le rayon pour cette colonne
        init_ray(&ray, x, game);
        
        // 2. Lancer le rayon jusqu'Ã  toucher un mur
        perform_dda(&ray, game);
        
        // 3. Calculer Ã  quelle distance est le mur
        calculate_wall_distance(&ray, game);
        
        // 4. Dessiner la ligne verticale pour cette colonne
        draw_vertical_line(x, &ray, game);
        
        x++;
    }
}


Explication :
-------------
Cette fonction est le CHEF D'ORCHESTRE du ray-casting.
Elle rÃ©pÃ¨te 1280 fois (une fois par colonne) les 4 Ã©tapes suivantes :
  1. Initialiser
  2. Chercher le mur
  3. Calculer la distance
  4. Dessiner


================================================================================
3. FONCTION init_ray() - INITIALISER LE RAYON
================================================================================

Objectif :
----------
PrÃ©parer les donnÃ©es mathÃ©matiques pour lancer un rayon depuis la position
du joueur dans une direction prÃ©cise.


Les variables importantes :
---------------------------

SchÃ©ma de la vision du joueur :

                        â†‘ Nord
                        â”‚
                        â”‚  dir (direction regard)
                        â”‚ â†—
                        â”‚/
            Ouest â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€ Est   â† Joueur (pos_x, pos_y)
                       /â”‚
                      / â”‚
                   plane â”‚
                        â†“ Sud

  â€¢ dir   = direction oÃ¹ le joueur regarde (un vecteur)
  â€¢ plane = plan de la camÃ©ra (perpendiculaire Ã  dir)
  â€¢ pos   = position du joueur dans la map


Calculs expliquÃ©s Ã‰TAPE PAR Ã‰TAPE :
------------------------------------

Ã‰TAPE 1 : camera_x
==================
Code :
    camera_x = 2 * x / (double)SCREEN_WIDTH - 1;

Qu'est-ce que c'est ?
  â€¢ Convertit le numÃ©ro de colonne (0 Ã  1279) en coordonnÃ©e (-1 Ã  +1)

Exemples concrets :
  x = 0          â†’ camera_x = -1.0  (tout Ã  gauche)
  x = 640        â†’ camera_x =  0.0  (au centre)
  x = 1279       â†’ camera_x = +1.0  (tout Ã  droite)


Ã‰TAPE 2 : Direction du rayon
=============================
Code :
    ray_dir_x = player.dir_x + player.plane_x * camera_x;
    ray_dir_y = player.dir_y + player.plane_y * camera_x;

Qu'est-ce que c'est ?
  â€¢ Calcule la direction dans laquelle le rayon va partir
  â€¢ dir   = direction oÃ¹ le joueur regarde
  â€¢ plane = plan de la camÃ©ra (largeur du champ de vision)

Exemple visuel si le joueur regarde vers le Nord :

                        â†‘ dir_y = -1
                        â”‚
            plane_x     â”‚ plane_x = 0.66
             â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
                        â”‚
                        â†“
                      joueur

Pour le rayon du CENTRE (camera_x = 0) :
    ray_dir_x = 0 + 0.66 * 0 = 0
    ray_dir_y = -1 + 0 * 0 = -1
    â†’ Le rayon va TOUT DROIT vers le nord

Pour le rayon de GAUCHE (camera_x = -1) :
    ray_dir_x = 0 + 0.66 * (-1) = -0.66
    ray_dir_y = -1 + 0 * (-1) = -1
    â†’ Le rayon part vers le NORD-OUEST

Pour le rayon de DROITE (camera_x = +1) :
    ray_dir_x = 0 + 0.66 * (+1) = 0.66
    ray_dir_y = -1 + 0 * (+1) = -1
    â†’ Le rayon part vers le NORD-EST


Ã‰TAPE 3 : Position de dÃ©part dans la grille
============================================
Code :
    map_x = (int)player.pos_x;  // Case X oÃ¹ se trouve le joueur
    map_y = (int)player.pos_y;  // Case Y oÃ¹ se trouve le joueur

Exemple :
    Si player.pos_x = 5.3 et player.pos_y = 8.7
    â†’ map_x = 5, map_y = 8

Pourquoi ?
  â€¢ La map est une grille de cases entiÃ¨res (0, 1, 2, 3...)
  â€¢ Le joueur peut Ãªtre ENTRE deux cases (position dÃ©cimale)
  â€¢ On arrondit Ã  l'entier infÃ©rieur pour savoir dans quelle case il est


Ã‰TAPE 4 : delta_dist - Distance entre intersections
====================================================
Code :
    delta_dist_x = fabs(1 / ray_dir_x);
    delta_dist_y = fabs(1 / ray_dir_y);

Qu'est-ce que c'est ?
  â€¢ La distance que le rayon doit parcourir pour traverser UNE case entiÃ¨re
  â€¢ delta_dist_x = distance horizontale entre deux lignes verticales
  â€¢ delta_dist_y = distance verticale entre deux lignes horizontales

Exemple visuel :

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
    â”‚       â”‚       â”‚       â”‚
    â”‚       â”‚       â”‚       â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤  â† delta_dist_y = distance verticale
    â”‚       â”‚â—â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”‚     entre ces lignes
    â”‚       â”‚   â†˜   â”‚       â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â†˜â”€â”€â”€â”€â”€â”¤
    â”‚       â”‚       â”‚   â†˜   â”‚
    â”‚       â”‚       â”‚     â†˜ â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
                 â†‘
            delta_dist_x


Ã‰TAPE 5 : step et side_dist - Direction et distance initiale
=============================================================
Code :
    if (ray_dir_x < 0)  // Rayon va vers la GAUCHE
    {
        step_x = -1;
        side_dist_x = (player.pos_x - map_x) * delta_dist_x;
    }
    else  // Rayon va vers la DROITE
    {
        step_x = 1;
        side_dist_x = (map_x + 1.0 - player.pos_x) * delta_dist_x;
    }
    
    // MÃªme chose pour Y
    if (ray_dir_y < 0)  // Rayon va vers le HAUT
    {
        step_y = -1;
        side_dist_y = (player.pos_y - map_y) * delta_dist_y;
    }
    else  // Rayon va vers le BAS
    {
        step_y = 1;
        side_dist_y = (map_y + 1.0 - player.pos_y) * delta_dist_y;
    }

Qu'est-ce que c'est ?
  â€¢ step_x : dans quel sens avancer (-1 = gauche, +1 = droite)
  â€¢ step_y : dans quel sens avancer (-1 = haut, +1 = bas)
  â€¢ side_dist_x : distance jusqu'Ã  la prochaine ligne VERTICALE
  â€¢ side_dist_y : distance jusqu'Ã  la prochaine ligne HORIZONTALE

Exemple visuel :

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
    â”‚       â”‚       â”‚       â”‚
    â”‚       â”‚       â”‚       â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚       â”‚   â—â”€â”€â”€â†’       â”‚  Joueur Ã  5.3, rayon va Ã  droite
    â”‚       â”‚   â†‘   â”‚       â”‚  side_dist_x = distance de 5.3 Ã  6.0
    â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚       â”‚   â”‚   â”‚       â”‚
    â”‚       â”‚   5   6       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜


================================================================================
4. FONCTION perform_dda() - TROUVER LE MUR
================================================================================

Objectif :
----------
Faire avancer le rayon case par case jusqu'Ã  toucher un mur.

DDA = Digital Differential Analysis (Analyse DiffÃ©rentielle Digitale)


Algorithme :
------------

void perform_dda(t_ray *ray, t_game *game)
{
    int hit = 0;
    
    while (!hit)
    {
        // Avancer dans la direction oÃ¹ la prochaine intersection
        // est la plus PROCHE
        
        if (ray->side_dist_x < ray->side_dist_y)
        {
            // La prochaine ligne VERTICALE est plus proche
            ray->side_dist_x += ray->delta_dist_x;
            ray->map_x += ray->step_x;
            ray->side = 0;  // Mur VERTICAL touchÃ©
        }
        else
        {
            // La prochaine ligne HORIZONTALE est plus proche
            ray->side_dist_y += ray->delta_dist_y;
            ray->map_y += ray->step_y;
            ray->side = 1;  // Mur HORIZONTAL touchÃ©
        }
        
        // VÃ©rifier si on a touchÃ© un mur
        if (game->map.grid[ray->map_y][ray->map_x] == '1')
            hit = 1;
    }
}


Animation du rayon (Ã©tape par Ã©tape) :
---------------------------------------

Ã‰tape 0 : Le joueur au centre, rayon part vers la droite
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚ 1 â”‚ 1 â”‚ 1 â”‚ 1 â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚ 1 â”‚ 0 â”‚â—â†’ 0 â”‚ 1 â”‚  â† Rayon part
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚ 1 â”‚ 0 â”‚ 0 â”‚ 1 â”‚
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

Ã‰tape 1 : Avancer en X (side_dist_x < side_dist_y)
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚ 1 â”‚ 1 â”‚ 1 â”‚ 1 â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚ 1 â”‚ 0 â”‚ 0 â†’â”‚ 1 â”‚  â† map_x++ (on avance Ã  droite)
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚ 1 â”‚ 0 â”‚ 0 â”‚ 1 â”‚
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

Ã‰tape 2 : Avancer en Y (side_dist_y < side_dist_x)
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚ 1 â”‚ 1 â”‚ 1 â”‚ 1 â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚ 1 â”‚ 0 â”‚ 0 â”‚ 1 â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚ 1 â”‚ 0 â”‚ 0 â†“â”‚ 1 â”‚  â† map_y++ (on descend)
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

Ã‰tape 3 : Avancer en X â†’ TOUCHE LE MUR !
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚ 1 â”‚ 1 â”‚ 1 â”‚ 1 â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚ 1 â”‚ 0 â”‚ 0 â”‚ 1 â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚ 1 â”‚ 0 â”‚ 0 â”‚â–ˆâ”‚  â† HIT! grid[y][x] == '1'
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜


Pourquoi la variable "side" ?
------------------------------

side = 0 : Mur VERTICAL (face Nord-Sud)
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”
    â”‚   â•‘   â”‚  â† On a touchÃ© cette face verticale
    â”‚   â•‘   â”‚     (cÃ´tÃ© Est ou Ouest du mur)
    â””â”€â”€â”€â”´â”€â”€â”€â”˜

side = 1 : Mur HORIZONTAL (face Est-Ouest)
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”
    â”‚   â”‚   â”‚
    â• â•â•â•â•¬â•â•â•â•£  â† On a touchÃ© cette face horizontale
    â”‚   â”‚   â”‚     (cÃ´tÃ© Nord ou Sud du mur)
    â””â”€â”€â”€â”´â”€â”€â”€â”˜

Cette information sert Ã  :
  1. Choisir la bonne TEXTURE (Nord, Sud, Est, Ouest)
  2. Calculer la DISTANCE correctement


================================================================================
5. FONCTION calculate_wall_distance() - CALCULER LA DISTANCE
================================================================================

Objectif :
----------
Calculer la distance PERPENDICULAIRE au mur pour Ã©viter l'effet "fish-eye"
(dÃ©formation de l'image).


Formules :
----------

if (ray->side == 0)  // Mur VERTICAL
    perp_wall_dist = (ray->map_x - player.pos_x + (1 - ray->step_x) / 2) 
                     / ray->ray_dir_x;
else  // Mur HORIZONTAL
    perp_wall_dist = (ray->map_y - player.pos_y + (1 - ray->step_y) / 2) 
                     / ray->ray_dir_y;


Pourquoi "perpendiculaire" ?
-----------------------------

Distance RÃ‰ELLE (mauvais) :
    â•”â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘           â•‘
    â•‘     â—â”€â”€â”€â”€â”€â”¼â”€â”€â†’ Rayon oblique = distance plus longue
    â•‘           â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•

Distance PERPENDICULAIRE (bon) :
    â•”â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘           â•‘
    â•‘     â—â”€â”€â”€â”€â”€â”¤    Projection perpendiculaire = distance correcte
    â•‘      â†˜    â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•

Sans correction, les murs sur les cÃ´tÃ©s paraÃ®traient plus Ã©loignÃ©s
que les murs au centre â†’ effet fish-eye (comme une lentille de poisson).


Calculer la HAUTEUR du mur Ã  l'Ã©cran :
---------------------------------------

Code :
    line_height = (int)(SCREEN_HEIGHT / perp_wall_dist);
    
    draw_start = -line_height / 2 + SCREEN_HEIGHT / 2;
    if (draw_start < 0)
        draw_start = 0;
    
    draw_end = line_height / 2 + SCREEN_HEIGHT / 2;
    if (draw_end >= SCREEN_HEIGHT)
        draw_end = SCREEN_HEIGHT - 1;


Pourquoi Ã§a marche ?
--------------------

Mur PROCHE â†’ petite distance â†’ GRANDE hauteur Ã  l'Ã©cran
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚  â† Prend TOUT l'Ã©cran (ou plus)
    â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚
    â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚
    â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Mur LOIN â†’ grande distance â†’ PETITE hauteur Ã  l'Ã©cran
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚        â”‚
    â”‚  â–ˆâ–ˆâ–ˆâ–ˆ  â”‚  â† Petit rectangle au centre
    â”‚        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜


Variables importantes :
-----------------------
  â€¢ line_height = hauteur totale de la ligne de mur
  â€¢ draw_start  = pixel Y oÃ¹ commence le mur (haut)
  â€¢ draw_end    = pixel Y oÃ¹ finit le mur (bas)


================================================================================
6. FONCTION draw_vertical_line() - DESSINER LA COLONNE
================================================================================

Objectif :
----------
Dessiner le plafond, le mur texturÃ©, et le sol pour UNE colonne de l'Ã©cran.


Structure d'une colonne :
--------------------------

         x (une colonne)
         â†“
      â”Œâ”€â”€â”
    0 â”‚â–ˆâ–ˆâ”‚ â† PLAFOND (ceiling color)
      â”‚â–ˆâ–ˆâ”‚
      â”‚â–ˆâ–ˆâ”‚
      â”‚â–“â–“â”‚ â† draw_start (dÃ©but du mur)
      â”‚â–“â–“â”‚
      â”‚â–“â–“â”‚ â† MUR TEXTURÃ‰
      â”‚â–“â–“â”‚
      â”‚â–“â–“â”‚ â† draw_end (fin du mur)
      â”‚â–‘â–‘â”‚
      â”‚â–‘â–‘â”‚ â† SOL (floor color)
  720 â”‚â–‘â–‘â”‚
      â””â”€â”€â”˜


Pseudo-code complet :
---------------------

void draw_vertical_line(int x, t_ray *ray, t_game *game)
{
    // ========================================
    // Ã‰TAPE 1 : Dessiner le PLAFOND
    // ========================================
    for (int y = 0; y < draw_start; y++)
    {
        put_pixel(x, y, game->ceiling.hex);
    }
    
    
    // ========================================
    // Ã‰TAPE 2 : Dessiner le MUR (avec texture)
    // ========================================
    
    // 2a. DÃ©terminer QUELLE TEXTURE utiliser (N/S/E/W)
    int tex_num = get_texture_num(ray);
    
    // 2b. Calculer OÃ™ exactement le rayon a touchÃ© le mur
    double wallX;
    if (ray->side == 0)  // Mur vertical
        wallX = player.pos_y + perp_wall_dist * ray->ray_dir_y;
    else  // Mur horizontal
        wallX = player.pos_x + perp_wall_dist * ray->ray_dir_x;
    
    wallX -= floor(wallX);  // Garder seulement la partie dÃ©cimale
    
    // 2c. Convertir en coordonnÃ©e X de la texture
    int tex_x = (int)(wallX * TEX_WIDTH);
    
    // Inverser si nÃ©cessaire
    if ((ray->side == 0 && ray->ray_dir_x > 0) ||
        (ray->side == 1 && ray->ray_dir_y < 0))
        tex_x = TEX_WIDTH - tex_x - 1;
    
    // 2d. Dessiner CHAQUE PIXEL du mur
    for (int y = draw_start; y < draw_end; y++)
    {
        // Calculer quelle LIGNE de la texture utiliser
        int d = y * 256 - SCREEN_HEIGHT * 128 + line_height * 128;
        int tex_y = ((d * TEX_HEIGHT) / line_height) / 256;
        
        // RÃ©cupÃ©rer la couleur du pixel de la texture
        int color = get_texture_color(game->texture.tex[tex_num], 
                                       tex_x, tex_y);
        
        // Dessiner le pixel Ã  l'Ã©cran
        put_pixel(x, y, color);
    }
    
    
    // ========================================
    // Ã‰TAPE 3 : Dessiner le SOL
    // ========================================
    for (int y = draw_end; y < SCREEN_HEIGHT; y++)
    {
        put_pixel(x, y, game->floor.hex);
    }
}


DÃ©terminer quelle texture utiliser :
-------------------------------------

int get_texture_num(t_ray *ray)
{
    if (ray->side == 0)  // Mur VERTICAL (Est ou Ouest)
    {
        if (ray->ray_dir_x > 0)
            return (3);  // Est (EA)
        else
            return (2);  // Ouest (WE)
    }
    else  // Mur HORIZONTAL (Nord ou Sud)
    {
        if (ray->ray_dir_y > 0)
            return (1);  // Sud (SO)
        else
            return (0);  // Nord (NO)
    }
}


Explication de wallX :
----------------------

wallX reprÃ©sente la position EXACTE oÃ¹ le rayon touche le mur,
exprimÃ©e en fraction (0.0 Ã  1.0).

Exemple :
    Si le mur fait 1 unitÃ© de large et que le rayon le touche :
      â€¢ Ã  25% de sa largeur â†’ wallX = 0.25
      â€¢ au milieu           â†’ wallX = 0.5
      â€¢ Ã  75%               â†’ wallX = 0.75

On utilise cette valeur pour choisir quelle COLONNE de la texture afficher.


Explication de tex_y :
----------------------

tex_y reprÃ©sente quelle LIGNE de la texture afficher pour un pixel Y donnÃ©.

Formule complexe pour Ã©viter les dÃ©formations :
    int d = y * 256 - SCREEN_HEIGHT * 128 + line_height * 128;
    int tex_y = ((d * TEX_HEIGHT) / line_height) / 256;

Plus simplement (version approximative) :
    tex_y = ((y - draw_start) * TEX_HEIGHT) / line_height;


================================================================================
7. RÃ‰CAPITULATIF COMPLET
================================================================================

Vue d'ensemble du processus :
------------------------------

Pour CHAQUE colonne X de l'Ã©cran (0 Ã  1279) :
    â†“
    1. init_ray(x)
       - Calculer la direction du rayon pour cette colonne
       - PrÃ©parer les variables de distance (delta_dist, side_dist, step)
    â†“
    2. perform_dda()
       - Avancer case par case dans la grille
       - S'arrÃªter quand on touche un mur ('1')
       - MÃ©moriser quel CÃ”TÃ‰ du mur est touchÃ© (side)
    â†“
    3. calculate_wall_distance()
       - Calculer la distance PERPENDICULAIRE au mur
       - Calculer la HAUTEUR du mur Ã  l'Ã©cran (line_height)
       - Calculer oÃ¹ commence et finit le mur (draw_start, draw_end)
    â†“
    4. draw_vertical_line(x)
       - Dessiner le PLAFOND (0 â†’ draw_start)
       - Dessiner le MUR TEXTURÃ‰ (draw_start â†’ draw_end)
       - Dessiner le SOL (draw_end â†’ SCREEN_HEIGHT)


Flux de donnÃ©es :
-----------------

INPUT:
  â€¢ game->player.pos_x, pos_y    (position du joueur)
  â€¢ game->player.dir_x, dir_y    (direction du regard)
  â€¢ game->player.plane_x, plane_y (plan de la camÃ©ra)
  â€¢ game->map.grid[][]           (la map avec les murs)

PROCESSING:
  â€¢ Lancer 1280 rayons (un par colonne)
  â€¢ Chaque rayon trouve le mur le plus proche
  â€¢ Calculer la distance et la hauteur

OUTPUT:
  â€¢ Une image 1280x720 pixels affichÃ©e Ã  l'Ã©cran
  â€¢ Effet 3D crÃ©Ã© par la perspective


================================================================================
8. ANALOGIE FINALE
================================================================================

Imaginez que vous prenez 1280 PHOTOS avec un appareil photo qui tourne
de gauche Ã  droite :

    Photo 0    : regarde complÃ¨tement Ã  GAUCHE
    Photo 1    : regarde un peu plus au centre
    Photo 2    : encore un peu plus
    ...
    Photo 640  : regarde droit devant (CENTRE)
    ...
    Photo 1279 : regarde complÃ¨tement Ã  DROITE

Pour chaque photo :
  1. Vous mesurez la distance du premier mur visible
  2. Vous dessinez une BARRE VERTICALE :
     - Plus le mur est PROCHE â†’ barre HAUTE
     - Plus le mur est LOIN   â†’ barre BASSE

En assemblant les 1280 barres cÃ´te Ã  cÃ´te, vous obtenez une vue 3D
du labyrinthe ! ğŸ®


RÃ©sultat visuel :
-----------------

    Murs proches = grandes barres :
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    
    Murs loin = petites barres :
        â–ˆâ–ˆ          â–ˆâ–ˆ
        â–ˆâ–ˆ          â–ˆâ–ˆ
    
    AssemblÃ©es ensemble :
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ        â–ˆâ–ˆ          â–ˆâ–ˆ        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ        â–ˆâ–ˆ          â–ˆâ–ˆ        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ                              â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ                              â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
         â†‘                                     â†‘
      mur proche                           mur proche


================================================================================
FIN DE L'EXPLICATION
================================================================================

Ressources complÃ©mentaires :
-----------------------------
â€¢ https://lodev.org/cgtutor/raycasting.html (tutoriel de rÃ©fÃ©rence)
â€¢ WikipÃ©dia : Ray casting
â€¢ VidÃ©o YouTube : "Ray Casting Tutorial"

Points clÃ©s Ã  retenir :
-----------------------
âœ… Un rayon par colonne de l'Ã©cran
âœ… DDA pour trouver le mur
âœ… Distance perpendiculaire (pas rÃ©elle)
âœ… Hauteur inversement proportionnelle Ã  la distance
âœ… Textures pour le rÃ©alisme

Bonne chance pour l'implÃ©mentation ! ğŸš€
