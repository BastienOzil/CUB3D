================================================================================
                    GUIDE POUR TERMINER LE PROJET CUB3D
================================================================================

OBJECTIF DU PROJET :
--------------------
Cr√©er une repr√©sentation graphique 3D r√©aliste de l'int√©rieur d'un labyrinthe 
en vue √† la premi√®re personne, en utilisant le principe du ray-casting avec la 
biblioth√®que MiniLibX.

================================================================================
√âTAPE 1 : COMPL√âTER LE PARSING DU FICHIER .CUB
================================================================================

A. Fonctions √† cr√©er/compl√©ter dans parse_map.c ou nouveau fichier :
   
   1. parse_texture_line() - Parser les lignes de textures (NO, SO, WE, EA)
      ‚Ä¢ V√©rifier l'identifiant (NO/SO/WE/EA)
      ‚Ä¢ Extraire le chemin du fichier texture
      ‚Ä¢ Stocker dans game->texture.north/south/west/east
   
   2. parse_color_line() - Parser les couleurs (F et C)
      ‚Ä¢ V√©rifier l'identifiant (F ou C)
      ‚Ä¢ Parser les valeurs R,G,B s√©par√©es par des virgules
      ‚Ä¢ V√©rifier que les valeurs sont entre 0 et 255
      ‚Ä¢ Convertir en format hexad√©cimal et stocker dans game->floor ou ceiling
   
   3. parse_map_grid() - Parser la grille de la map
      ‚Ä¢ Trouver o√π commence la map (apr√®s les textures et couleurs)
      ‚Ä¢ Allouer et remplir game->map.grid[]
      ‚Ä¢ Calculer game->map.width et game->map.height
      ‚Ä¢ Garder les espaces tels quels (font partie de la map)

B. Fonctions utilitaires √† cr√©er :
   
   ‚Ä¢ ft_strtrim_whitespace() - Enlever les espaces au d√©but/fin d'une ligne
   ‚Ä¢ create_rgb() - Convertir R,G,B en format hexad√©cimal (R << 16 | G << 8 | B)
   ‚Ä¢ free_split() - Lib√©rer un tableau de cha√Ænes


================================================================================
√âTAPE 2 : VALIDATION COMPL√àTE DE LA MAP
================================================================================

A. Compl√©ter check_map.c :
   
   1. validate_map_walls() - V√©rifier que la map est ferm√©e
      ‚Ä¢ V√©rifier que tous les '0' et positions joueur sont entour√©s de murs
      ‚Ä¢ V√©rifier les bords de la map
      ‚Ä¢ Utiliser un algorithme de flood-fill ou v√©rifier chaque cellule
      ‚Ä¢ Les espaces peuvent √™tre probl√©matiques aux bords
   
   2. V√©rifications √† faire :
      ‚Ä¢ Un seul joueur (N, S, E, ou W)
      ‚Ä¢ Caract√®res valides uniquement (0, 1, N, S, E, W, espaces)
      ‚Ä¢ Map rectangulaire (compl√©ter avec espaces si n√©cessaire)
      ‚Ä¢ Pas de trous dans les murs


================================================================================
√âTAPE 3 : INITIALISATION DU JEU ET DES TEXTURES
================================================================================

A. Cr√©er un fichier init_game.c avec :
   
   1. init_game() - Initialiser la structure game
      ‚Ä¢ Mettre tous les pointeurs √† NULL
      ‚Ä¢ Initialiser les couleurs √† -1
      ‚Ä¢ Initialiser les dimensions d'√©cran
   
   2. init_player() - Initialiser la position et direction du joueur
      ‚Ä¢ game->player.pos_x = game->map.player_x + 0.5
      ‚Ä¢ game->player.pos_y = game->map.player_y + 0.5
      ‚Ä¢ Selon player_dir (N/S/E/W), d√©finir dir_x, dir_y
      ‚Ä¢ D√©finir le plan de la cam√©ra (plane_x, plane_y) perpendiculaire √† dir
      
      Exemple pour 'N' (Nord) :
        dir_x = 0, dir_y = -1
        plane_x = 0.66, plane_y = 0
   
   3. load_textures() - Charger les textures depuis les fichiers
      ‚Ä¢ Utiliser mlx_xpm_file_to_image() pour chaque texture
      ‚Ä¢ Stocker dans game->texture.tex[0..3] (N, S, E, W)
      ‚Ä¢ R√©cup√©rer l'adresse avec mlx_get_data_addr()
      ‚Ä¢ V√©rifier que les fichiers existent


================================================================================
√âTAPE 4 : INITIALISATION DE LA FEN√äTRE MLX
================================================================================

A. Cr√©er un fichier start_game.c avec :
   
   1. start_game() - D√©marrer le jeu avec MiniLibX
      ‚Ä¢ game->mlx = mlx_init()
      ‚Ä¢ game->win = mlx_new_window(mlx, SCREEN_WIDTH, SCREEN_HEIGHT, "cub3D")
      ‚Ä¢ Cr√©er l'image principale : mlx_new_image()
      ‚Ä¢ load_textures()
      ‚Ä¢ D√©finir les hooks (√©v√©nements) :
        - mlx_hook() pour la fermeture de fen√™tre (X rouge)
        - mlx_key_hook() ou mlx_hook() pour les touches
        - mlx_loop_hook() pour le rendu continu
      ‚Ä¢ mlx_loop(game->mlx)


================================================================================
√âTAPE 5 : IMPL√âMENTER LE RAY-CASTING (COEUR DU PROJET)
================================================================================

A. Cr√©er un fichier raycasting.c avec :
   
   1. raycasting() - Fonction principale du ray-casting
      ‚Ä¢ Boucle pour chaque colonne x de l'√©cran (0 √† SCREEN_WIDTH)
      ‚Ä¢ Pour chaque x :
        a) init_ray() - Initialiser le rayon
        b) perform_dda() - Algorithme DDA pour trouver le mur
        c) calculate_wall_distance() - Calculer la distance perpendiculaire
        d) draw_vertical_line() - Dessiner la ligne verticale textur√©e
   
   2. init_ray() - Initialiser les variables du rayon pour la colonne x
      ‚Ä¢ camera_x = 2 * x / (double)SCREEN_WIDTH - 1
      ‚Ä¢ ray_dir_x = player.dir_x + player.plane_x * camera_x
      ‚Ä¢ ray_dir_y = player.dir_y + player.plane_y * camera_x
      ‚Ä¢ map_x = (int)player.pos_x
      ‚Ä¢ map_y = (int)player.pos_y
      ‚Ä¢ Calculer delta_dist_x et delta_dist_y
      ‚Ä¢ D√©terminer step_x, step_y et side_dist initiales
   
   3. perform_dda() - Algorithme Digital Differential Analysis
      ‚Ä¢ Boucle while (!hit) :
        - Avancer dans la grille (map_x ou map_y selon side_dist)
        - V√©rifier si on touche un mur (map.grid[map_y][map_x] == '1')
        - Enregistrer quel c√¥t√© du mur est touch√© (side = 0 ou 1)
   
   4. calculate_wall_distance() - Calculer la distance au mur
      ‚Ä¢ Si side == 0 : perp_wall_dist = (map_x - pos_x + (1-step_x)/2) / ray_dir_x
      ‚Ä¢ Si side == 1 : perp_wall_dist = (map_y - pos_y + (1-step_y)/2) / ray_dir_y
      ‚Ä¢ Calculer line_height = (int)(SCREEN_HEIGHT / perp_wall_dist)
      ‚Ä¢ Calculer draw_start et draw_end
   
   5. draw_vertical_line() - Dessiner une ligne de texture
      ‚Ä¢ D√©terminer quelle texture utiliser (N/S/E/W selon side et step)
      ‚Ä¢ Calculer wallX (o√π exactement le mur a √©t√© touch√©)
      ‚Ä¢ Calculer tex_x (colonne de la texture √† utiliser)
      ‚Ä¢ Boucle pour chaque pixel vertical :
        - Calculer tex_y (ligne de la texture)
        - R√©cup√©rer la couleur du pixel de la texture
        - Mettre le pixel dans l'image avec mlx_pixel_put ou directement dans img.addr
      ‚Ä¢ Dessiner le sol et le plafond pour cette colonne


================================================================================
√âTAPE 6 : GESTION DES COULEURS SOL/PLAFOND
================================================================================

A. Dans draw_vertical_line() ou fonction s√©par√©e :
   
   1. Dessiner le plafond :
      ‚Ä¢ De y=0 √† y=draw_start : couleur game->ceiling.hex
   
   2. Dessiner le sol :
      ‚Ä¢ De y=draw_end √† y=SCREEN_HEIGHT : couleur game->floor.hex


================================================================================
√âTAPE 7 : CONTR√îLES CLAVIER
================================================================================

A. Cr√©er un fichier controls.c avec :
   
   1. key_press() - G√©rer les touches press√©es
      ‚Ä¢ ESC (keycode 65307) : close_game()
      ‚Ä¢ W (keycode 119 ou 13) : move_forward()
      ‚Ä¢ S (keycode 115 ou 1) : move_backward()
      ‚Ä¢ A (keycode 97 ou 0) : strafe_left() [optionnel]
      ‚Ä¢ D (keycode 100 ou 2) : strafe_right() [optionnel]
      ‚Ä¢ Fl√®che gauche : rotate_left()
      ‚Ä¢ Fl√®che droite : rotate_right()
   
   2. move_forward() - Avancer dans la direction du regard
      ‚Ä¢ new_x = player.pos_x + player.dir_x * MOVE_SPEED
      ‚Ä¢ new_y = player.pos_y + player.dir_y * MOVE_SPEED
      ‚Ä¢ V√©rifier que la nouvelle position n'est pas dans un mur
      ‚Ä¢ Si valide : mettre √† jour pos_x et pos_y
   
   3. move_backward() - Reculer
      ‚Ä¢ M√™me logique mais soustraire au lieu d'ajouter
   
   4. rotate_left() - Rotation √† gauche
      ‚Ä¢ Faire tourner dir_x, dir_y avec matrice de rotation
      ‚Ä¢ Faire tourner plane_x, plane_y aussi
      ‚Ä¢ Angle = -ROT_SPEED
   
   5. rotate_right() - Rotation √† droite
      ‚Ä¢ Angle = +ROT_SPEED
   
   6. close_game() - Fermer proprement le jeu
      ‚Ä¢ D√©truire les textures et images
      ‚Ä¢ D√©truire la fen√™tre
      ‚Ä¢ free_game()
      ‚Ä¢ exit(0)


================================================================================
√âTAPE 8 : RENDU EN BOUCLE
================================================================================

A. Cr√©er une fonction render_frame() :
   
   1. Effacer l'image pr√©c√©dente (ou cr√©er nouvelle image)
   2. Appeler raycasting() pour dessiner la sc√®ne
   3. mlx_put_image_to_window() pour afficher l'image
   4. Retourner 0 pour continuer la boucle


================================================================================
√âTAPE 9 : GESTION DE LA M√âMOIRE
================================================================================

A. Cr√©er un fichier cleanup.c avec :
   
   1. free_game() - Lib√©rer toutes les ressources
      ‚Ä¢ free_map()
      ‚Ä¢ Lib√©rer les chemins de textures
      ‚Ä¢ D√©truire les images MLX si cr√©√©es
      ‚Ä¢ Lib√©rer game->mlx si cr√©√©
   
   2. free_map() - Lib√©rer la grille de la map
      ‚Ä¢ Boucle pour lib√©rer chaque ligne
      ‚Ä¢ Lib√©rer le tableau principal


================================================================================
√âTAPE 10 : GESTION DES ERREURS
================================================================================

A. Cr√©er un fichier error.c avec :
   
   1. ft_error() - Afficher un message d'erreur
      ‚Ä¢ Afficher "Error\n" sur stderr
      ‚Ä¢ Afficher le message sp√©cifique
      ‚Ä¢ Retourner 1 (code d'erreur)
   
   2. Cas d'erreurs √† g√©rer :
      ‚Ä¢ Mauvais nombre d'arguments
      ‚Ä¢ Fichier .cub non trouv√©
      ‚Ä¢ Extension invalide
      ‚Ä¢ Textures non trouv√©es
      ‚Ä¢ Couleurs invalides (hors range 0-255)
      ‚Ä¢ Map invalide (non ferm√©e, plusieurs joueurs, etc.)
      ‚Ä¢ Allocation m√©moire √©chou√©e
      ‚Ä¢ Initialisation MLX √©chou√©e


================================================================================
√âTAPE 11 : TESTS ET D√âBOGAGE
================================================================================

1. Tester avec diff√©rentes maps :
   ‚Ä¢ Map simple (comme dans l'exemple)
   ‚Ä¢ Map avec espaces
   ‚Ä¢ Map complexe
   ‚Ä¢ Maps invalides (pour tester la gestion d'erreurs)

2. V√©rifier :
   ‚Ä¢ Les textures s'affichent correctement sur chaque c√¥t√©
   ‚Ä¢ Les couleurs sol/plafond sont bonnes
   ‚Ä¢ Les d√©placements sont fluides
   ‚Ä¢ Les rotations fonctionnent
   ‚Ä¢ ESC et X rouge ferment proprement
   ‚Ä¢ Pas de fuites m√©moire (valgrind)

3. Utiliser des outils :
   ‚Ä¢ valgrind --leak-check=full ./cub3D maps/map.cub
   ‚Ä¢ Afficher des printf pour d√©boguer le ray-casting


================================================================================
ORDRE D'IMPL√âMENTATION RECOMMAND√â
================================================================================

1. ‚úÖ PARSING : Terminer parse_texture_line(), parse_color_line(), parse_map_grid()
2. ‚úÖ VALIDATION : Terminer validate_map_walls()
3. ‚úÖ INIT : Impl√©menter init_game(), init_player(), load_textures()
4. ‚úÖ MLX : Impl√©menter start_game() (fen√™tre de base)
5. ‚úÖ RAY-CASTING : Impl√©menter l'algorithme complet (√©tape la plus complexe)
6. ‚úÖ AFFICHAGE : Dessiner murs, sol, plafond avec textures
7. ‚úÖ CONTROLES : Impl√©menter d√©placements et rotations
8. ‚úÖ CLEANUP : Impl√©menter free_game() et gestion erreurs
9. ‚úÖ TESTS : Tester et corriger les bugs


================================================================================
FICHIERS √Ä CR√âER/COMPL√âTER
================================================================================

Fichiers existants √† compl√©ter :
- srcs/parse_map.c (compl√©ter les fonctions manquantes)
- srcs/check_map.c (ajouter validate_map_walls)
- srcs/main.c (d√©j√† bon)

Nouveaux fichiers √† cr√©er dans srcs/ :
- parse_texture.c (parse_texture_line, parse_color_line)
- parse_utils.c (ft_strtrim_whitespace, create_rgb, etc.)
- init_game.c (init_game, init_player)
- load_textures.c (load_textures)
- start_game.c (start_game, render_frame)
- raycasting.c (raycasting, init_ray, perform_dda, etc.)
- draw.c (draw_vertical_line, fonctions de dessin)
- controls.c (key_press, move_forward, rotate_left, etc.)
- cleanup.c (free_game, free_map)
- error.c (ft_error)

N'oublie pas de mettre √† jour le Makefile avec tous les nouveaux fichiers !


================================================================================
RESSOURCES UTILES
================================================================================

1. Tutoriels Ray-Casting :
   - https://lodev.org/cgtutor/raycasting.html (EXCELLENT tutoriel, tr√®s d√©taill√©)
   - Ce tutoriel explique tout l'algorithme √©tape par √©tape

2. Documentation MiniLibX :
   - Voir les man pages dans minilibx-linux/
   - Fonctions principales : mlx_init, mlx_new_window, mlx_new_image,
     mlx_get_data_addr, mlx_put_image_to_window, mlx_hook, mlx_loop

3. Concepts math√©matiques :
   - Vecteurs 2D (position, direction)
   - Rotation de vecteurs (matrice de rotation)
   - DDA (Digital Differential Analysis)
   - Distance perpendiculaire (pour √©viter l'effet fish-eye)


================================================================================
CONSEILS IMPORTANTS
================================================================================

‚Ä¢ Avance √©tape par √©tape, teste chaque partie avant de passer √† la suivante
‚Ä¢ Le ray-casting est la partie la plus complexe, prends ton temps
‚Ä¢ Utilise des printf pour afficher les valeurs et comprendre ce qui se passe
‚Ä¢ Commence avec une map simple pour d√©boguer
‚Ä¢ V√©rifie les fuites m√©moire r√©guli√®rement avec valgrind
‚Ä¢ G√®re les erreurs √† chaque allocation et ouverture de fichier
‚Ä¢ Teste avec des maps invalides pour v√©rifier ta gestion d'erreurs
‚Ä¢ N'h√©site pas √† dessiner des sch√©mas pour comprendre le ray-casting


================================================================================
BONUS (√† faire SEULEMENT si la partie obligatoire est parfaite)
================================================================================

1. Collisions avec les murs (v√©rifier dans move_forward/backward)
2. Minimap syst√®me (afficher une petite carte en haut)
3. Portes qui s'ouvrent/ferment (nouveau caract√®re dans la map)
4. Sprites anim√©s (ennemis, objets)
5. Rotation avec la souris (mlx_mouse_move)


================================================================================
BON COURAGE ! üöÄ
================================================================================

Si tu suis ces √©tapes dans l'ordre, ton projet sera termin√© progressivement.
Commence par le parsing, puis la validation, puis l'initialisation, et enfin
le ray-casting qui est le c≈ìur du projet.

N'oublie pas : teste apr√®s chaque √©tape importante !
